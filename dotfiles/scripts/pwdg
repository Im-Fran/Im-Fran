#!/usr/bin/env zsh
# pwdg - Password generator using openssl
#
# Usage:
#   pwdg -d 14 -a -s -u -l
#
# Options:
#   -d N     : password length (default 14)
#   -a [bool]: include digits (default true)
#   -s [bool]: include special characters (default false)
#   -u [bool]: include uppercase letters (default true)
#   -l [bool]: include lowercase letters (default true)
#
# Boolean flags:
#   - Passing without a value means "true" (e.g., -s).
#   - You can also do -s=false, -a=0, -u=yes, etc.

set -euo pipefail

print_help() {
  cat <<EOF
pwdg - Password generator (openssl)

Usage: pwdg [-d N] [-a[=bool]] [-s[=bool]] [-u[=bool]] [-l[=bool]]

-d N    Length (default 14)
-a      Include digits (default true)
-s      Include special characters (default false)
-u      Include uppercase letters (default true)
-l      Include lowercase letters (default true)

Examples:
  pwdg -d 16 -s          # 16 chars, include specials
  pwdg -d 12 -a=false -u # 12 chars, no digits, include uppercase
EOF
}

# helper: normalize boolean-like values
parse_bool() {
  local val="$1"
  if [[ -z "$val" ]]; then
    return 0  # empty -> true
  fi
  case "${val:l}" in
    1|y|yes|true|on) return 0 ;;
    0|n|no|false|off) return 1 ;;
    *)
      echo "Error: invalid boolean value: '$val'" >&2
      exit 2
      ;;
  esac
}

# defaults
digits=14
use_digits=true
use_specials=false
use_upper=true
use_lower=true

# parse args
while [[ $# -gt 0 ]]; do
  arg=$1
  shift
  case $arg in
    -h|--help) print_help; exit 0 ;;
    -d|--digits)
      [[ $# -gt 0 ]] || { echo "Error: -d requires a value" >&2; exit 2; }
      digits=$1; shift
      ;;
    -d=*) digits="${arg#*=}" ;;
    -a|--digits)
      use_digits=true
      if [[ $# -gt 0 && ! $1 == -* ]]; then
        parse_bool "$1" && use_digits=true || use_digits=false
        shift
      fi
      ;;
    -a=*) parse_bool "${arg#*=}" && use_digits=true || use_digits=false ;;
    -s|--specials)
      use_specials=true
      if [[ $# -gt 0 && ! $1 == -* ]]; then
        parse_bool "$1" && use_specials=true || use_specials=false
        shift
      fi
      ;;
    -s=*) parse_bool "${arg#*=}" && use_specials=true || use_specials=false ;;
    -u|--upper)
      use_upper=true
      if [[ $# -gt 0 && ! $1 == -* ]]; then
        parse_bool "$1" && use_upper=true || use_upper=false
        shift
      fi
      ;;
    -u=*) parse_bool "${arg#*=}" && use_upper=true || use_upper=false ;;
    -l|--lower)
      use_lower=true
      if [[ $# -gt 0 && ! $1 == -* ]]; then
        parse_bool "$1" && use_lower=true || use_lower=false
        shift
      fi
      ;;
    -l=*) parse_bool "${arg#*=}" && use_lower=true || use_lower=false ;;
    *)
      echo "Unknown option: $arg" >&2
      print_help
      exit 2
      ;;
  esac
done

# validations
if ! [[ $digits == <-> ]]; then
  echo "Error: -d must be a positive integer." >&2
  exit 2
fi
if (( digits <= 0 )); then
  echo "Error: -d must be greater than 0." >&2
  exit 2
fi

if ! $use_specials && ! $use_digits && ! $use_upper && ! $use_lower; then
  echo "Error: invalid configuration - no character sets enabled." >&2
  exit 2
fi

# build character set
charset=""
[[ $use_lower == true ]]  && charset+=$(printf '%s' "abcdefghijklmnopqrstuvwxyz")
[[ $use_upper == true ]]  && charset+=$(printf '%s' "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
[[ $use_digits == true ]] && charset+=$(printf '%s' "0123456789")

# specials: . , - _ { } * + ! " # $ % & / ( ) [ ] ; : @
# We append '-' at the end to avoid tr/option confusion; here it's just a plain string.
if $use_specials; then
  charset+=$(printf '%s' '.,_{}*+!"#$%&/()[];:@-')
fi

if [[ -z "$charset" ]]; then
  echo "Error: empty character set." >&2
  exit 2
fi

# generate N characters by indexing into charset using random bytes
#  - Use raw bytes from openssl
#  - Convert bytes to unsigned decimals
#  - Mod by charset length to pick a character
len=${#charset}
need=$digits
out=""

# grab a little extra entropy to avoid re-calling openssl in most cases
bytes_needed=$(( need * 2 ))
# macOS/BSD od is fine here
nums=(${(z)$(openssl rand $bytes_needed | od -An -tu1 -v | tr -s '[:space:]' ' ')})
i=1
while [[ ${#out} -lt $need ]]; do
  if (( i > ${#nums} )); then
    # top up if we run out
    nums=(${(z)$(openssl rand $bytes_needed | od -An -tu1 -v | tr -s '[:space:]' ' ')})
    i=1
  fi
  byte=${nums[i]}
  i=$(( i + 1 ))
  idx=$(( (byte % len) + 1 ))      # 1-based for zsh slicing
  out+="${charset[$idx,$idx]}"
done

printf '%s\n' "${out[1,$digits]}"
exit 0
